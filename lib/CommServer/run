#!/bin/bash
# CommServer.run -- run the server, reading from .q-spool into .q until empty

# exit if an instance is already running (pid file exists and is not stale):
# test -s .@PID && exit 1
test -s .@PID && test -d /proc/$(<.@PID) && exit 1
trap 'rm .@PID' TERM EXIT
echo $$ > .@PID

# close stdin, redirect stdout and stderr to files:
exec 0>&- 1>.@OUT 2>.@ERR

error() { echo "$@" >&2 && exit 1; }

tob=/usr/local/bin/tob

queue=.q
spool=.q-spool

# read settings from config file:
test -e : -o -e .: && {
    rcfile=.: && test -e : && rcfile=: # rc file : supersedes .:
    unset ok
    while read -r tag value; do
        test ${tag:0:1} == '[' && {
            block=$tag
            continue
            }
        test "$block" == "[$TOB_method]" || continue
        value=${value#*=}
        case $tag in
            sleep_sec) sleep_sec=${sleep_sec:-$value};;
            random_mod) random_mod=${random_mod:-$value};;
            random_ofs) random_ofs=${random_ofs:-$value};;
            *) error unknown attribute: $tag;;
        esac
    done < "$rcfile"
    }

test -n "$sleep_sec" || sleep_sec=2

# echo ok 1

process_spool() { # move sites into queue unless delay, return 0 if empty
    delayed=0
    despooled=0
    for site in .q-spool/*; do
    
        id="${site##*/}"
        test "$id" == '*' && return 0
    
      # echo spooled: $id
    
        # leave site in spool if also in queue:
        # ... NO ... drop it from the spool if that's the case
        test -e $queue/$id && {
            rm $site
            echo drop duplicate $site from spool
            continue
            }
    
        # move site into queue if no delay attribute:
        test -e $site/q-DELAY || {
            mv $site $queue
            queued=$(($queued+1))
            despooled=$(($despooled+1))
            continue
            }
    
        # move site into queue if delay has expired:
        test $site/q-DELAY -nt .@NOW || {
            mv $site $queue
            queued=$(($queued+1))
            despooled=$(($despooled+1))
            continue
            }
    done
    test $despooled -gt 0 && return 2
    return 1
    }

# echo ok 1a

process_queue() { # return value: 0 if empty, else 1
    choices=()
    n=0
    for site in $queue/*; do
    
        id="${site#*/}"
        test "$id" == '*' && return 0 
    
        # remove site from queue if timeout has elapsed:
        test $site/q-TIMEOUT -nt .@NOW || {
            touch $site/q-FAILED
            rm $site
          # echo timeout: $site
            tmouts=$(($tmouts+1))
            continue
            }
    
        # work around bug that .q/site.foo has to be .q.site.foo:
        tsite=${site/\//.}

        # aquire a route or skip this site:
        route=$($tob $tsite.lock-route --release probe)
        test -n "$route" || continue

        # calculate one or more metrics based on the route...
    
        # metric for number of hops over minimum:
        min_hops=1
        test -e $site/@min-hops && min_hops=$(<$site/@min-hops)
        extra_hops=$(( (${#route[@]} - $min_hops) * 20 ))
    
        # age is time in seconds since last successful session:
        age=0
      # test -e $site/@session &&
      #     age=$(($now - $(stat -c %Y $site/@session)))
        test -s $site/@last-session-end-time &&
            age=$(($now - $(<$site/@last-session-end-time)))
        # convert age to crude/approximate logarithmic value:
        test $age -lt 0 && age=0
        age=$(( (${#age} - 1)* 10 + ${age:0:1} ))
    
        sum=$(( $age - $extra_hops ))
    
        test -e $site/q-PRIORITY && 
            sum=$(( $sum + $(<$site/q-PRIORITY) ))
    
        test -e $site/q-PRIORITY=* && {
            value=$(ls $site/q-PRIORITY=*)
            sum=$(( $sum + ${value#*=} ))
            }
    
        test -n "$random_mod" &&
            sum=$(( $sum + $RANDOM % $random_mod + $random_ofs ))
    
        # prevent values < 0 in case of trouble with leading - sign:
        test $sum -lt 0 && sum=0

      # echo METRIC-SITE: $sum-$site
      # choices="$choices $sum-$site"
        choices[$n]=$sum-$site
        n=$(($n+1))
    done
    return 1
    }

# echo ok 1b

check_notify_pool() { # check candidates for timeout
    for site in .q-notified/*; do
    
        id=${site##*/}
        test "$id" == '*' && return 0
    
      # echo notified: $site
    
        # move site into queue if delay has expired:
        test $site/q-TIMEOUT -nt .@NOW && continue

        # timeout has expired, so unlock route and remove site from pool
        s=$(readlink -f $site)
        rm $site
        notified_tmouts=$(($notified_tmouts+1))
        $tob $s.unlock-route $id
        
      # echo timeout: $site removed from notified, unlocked

        ## NOTE: the above may have/be a race condition, so needs work...
        ## we remove the link before unlocking the route... maybe that's ok?
    
    done
    return 1
    }

# echo ok 1c

date +%s > .@START

loops=0
passed=0
queued=0
tmouts=0
notified_tmouts=0
while true; do
    # quit if the pid file is not set
    test -s .@PID || error pid file .@PID was removed or reset

  # echo ok 2

    date +%s > .@NOW
    now=$(<.@NOW)

  # process_spool && process_queue && check_notify_pool && exit 0

    choices=()
    process_spool; scan_spool=$?
    process_queue; scan_queue=$?
    check_notify_pool; scan_notified=$?
    
    # exit values from the above will be 0 when directory is empty, i.e. done
    test $scan_spool == 0 -a $scan_queue == 0 -a $scan_notified == 0 && {
        elapsed=$(($(date +%s)-$(<.@START)))
        printf "%s.%s exiting after %d/%d passed/queued, %d+%d timeouts, %d loops, %ds\n" \
            $TOB_object $TOB_method $passed $queued $tmouts $notified_tmouts $loops $elapsed
        printf "%d passed, %d queued, %d q-tmout, %d n-tmout, %d loops, %ds\n" \
            $passed $queued $tmouts $notified_tmouts $loops $elapsed | \
            $tob $self.log.store
        exit 0
        }

  # echo ok 3

    loops=$(($loops + 1))

  # echo something is in the spool or queue
    test -n "$choices" || {
      # echo sleep...
        sleep $sleep_sec && continue
        }
    
  # echo ok 4
    # sort choices and select the one with the greatest value:
    choice=$(printf "%s\n" "${choices[@]}" | sort -n | tail -n 1)

  # echo SELECT $choice from ${#choices[@]} choices \(loop $loops\)
  # rate100=$((${#choices[@]} * 100 / $(($(date +%s)-$now))
  # len=${#rate100}
    
    printf "SELECT %s from %d choices, %ds\n" \
        $choice ${#choices[@]} $(($(date +%s)-$now))

  # echo ok 5
    site=${choice#*-}
    test -e $site || error ERROR: $site not found

    tsite=${site/\//.}
    
    id=$(<$site/@id)
    $tob $tsite.lock-route $id || {
        # should have worked, so just bail and better luck next time
        echo failed to aquire route to $site... >&2
        sleep $sleep_sec
        continue
        } 

    # ASSERT: the route to $site is locked, ready to go!
    # should we check that this route is the same as the one checked above? Nah.
    
    touch $site/q-PASSED
    
    # remove site from queue:
    rm $site || error failed to dequeue $site...
  # echo dequeued: $site
    passed=$(($passed+1))

    sleep $sleep_sec
done

exit

NAME
    CommServer.run -- process call queue spool and queue

DESCRIPTION
    The goal is to select a site to call after weighing various metrics,
    including time since last contact, caller-assigned priority, availability
    cost of routes, and perhaps others.

    The CommServer.call method provides the caller interface to this method,
    creating an object in the queue spool.  This method moves objects from
    the spool into the queue, unless the optional delay interval has not 
    elapsed.

    Each object in the queue is evaluated along with the others, and one
    chosen...

    Objects are removed from the queue if the timeout period has elapsed.

IMPLEMENTATION NOTES
    The queue is a form of priority queue, where the effective priority
    metric is not fully defined on entry to the queue, but also depends
    dynamically with availability and cost of routing nodes and on other
    factors.

    The age in seconds is converted to something like a logarithm in base
    10 by concatenating the number of digits minus 1 and the first digit.

OPTIONS
    
AUTHOR
    Ken.Irving@alaska.edu 2010


