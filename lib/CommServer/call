#!/bin/bash

error () {
    test -n "$1" -a $1 == --exit && shift && exitvalue=$1 && shift
    tmstamp=$(date --iso=sec)
    printf "%s %s %s\n" $tmstamp ${exitvalue:--} "$*" >&2
    # do not output to error log if --exit 1 is given:
    test -n "$exitvalue" -a $exitvalue == 1 && exit 1
    printf "%s %s %s\n" $tmstamp ${exitvalue:--} "$*" >> /tmp/commserver-call-error
    # do not exit unless --exit N is given:
    test -n "$exitvalue" && exit $exitvalue
    }

tob=/usr/local/bin/tob
self=.

# default values for options:
timeout=60
delay=0
unset notify
unset notified

synopsis="$(basename $0) [--notify|--notified|-h|--help] [SITE [SITE_OPTIONS]]"

# parse and handle command line options:
while test -n "$1" -a "${1:0:1}" == '-'; do
    opt=$1 && shift
    case $opt in
        --notify)   notify=1;;
        --notified) notified=1;;
        --help)     exec awk '/^NAME$/{ok=1}ok{print}' $0;;
        -h)         echo $synopsis && exit 0;;
        *)          error --exit 11 unknown option: $opt;;
    esac
done

query=( call "$@" )
unset query[0]

# skip dialog if a non-option argument (the site to call) is present:
# test -n "$1" || while read -a query -p "query: "; do
test -n "$1" || { # no arguments given, so run query loop:
    printf 'query: '
    while read -a query; do
        # special case: filter trailing \r character if present in last word:
        i=$((${#query[@]}-1))
        query[$i]=${query[$i]%$'\r'}
        cmd=$query
        unset query[0]
        case $cmd in
    
            call)   break
                    ;;
    
            ls)     ls "${query[@]}"
                    ;;
    
            q|quit) echo goodbye!
                    exit 0
                    ;;
    
            h)      printf "    %s\n" \
                        'call SITE [OPTIONS] -- queue site to call' \
                        'ls [...]           -- list commserver object contents' \
                        'q|quit             -- exit' \
                        'h                  -- show short help' \
                        'help               -- show man page'
                    ;;
    
            help)   awk '/^NAME$/{ok=1}ok{print}' $0
                    ;;
    
            *)      printf "\a?\n"
                    ;;
    
        esac
        printf 'query: '
    done
    }

site=${query[1]}
test -n "$site" || error --exit 26 no site specified in query "<${query[*]}>"
unset query[1]

# echo call $site with args: "${query[@]}" 
test -d "$site" || { # site does not resolve directly, so try harder...
    for dir in _ _/*; do
        test -d $dir/$site || continue
        site=$dir/$site
        break
    done
    test -d $site || error --exit 12 no site: $site
    test $site != ${site#_/transition} && error resolved site as $site
    }

# echo DEBUG 1 $site

i=2 # skip entries 0 ('call') and 1 (the site)
while test -n "${query[$i]}"; do
    case ${query[$i]} in
        --notify)
            notify=1
            ;;

        --notified)
            notified=1
            ;;

        --priority=*)
            priority=${query[$i]#*=}
            ;;

        --priority)
            i=$((i+1))
            priority=${query[$i]}
            ;;

        --timeout=*)
            timeout=${query[$i]#*=}
            ;;

        --timeout)
            i=$((i+1))
            timeout=${query[$i]}
            ;;

        --delay=*)
            delay=${query[$i]#*=}
            ;;

        --delay)
            i=$((i+1))
            delay=${query[$i]}
            ;;

        *)  error --exit 13 unknown option: ${query[$i]}
            ;;
    esac
    i=$((i+1))
done

# site @id attribute should be unique, so use for link name:
test -e "$site/@id" || error --exit 14 no $site/@id attribute found
id=$(<$site/@id)
test -n "$id" || error --exit 15 failed to read from $site/@id attribute
id=${id// /_} # just in case: replace spaces with underscores, if any

test -n "$notified" && {
    test -e .q-notified/$id || error --exit 1 site $id $site is not in notified queue
    rm .q-notified/$id && exec $tob $site.call
    error --exit 17 failed to remove $id for $site from notified queue
    }

test -e .q-notified/$id && error --exit 18 call $site missing --notified option

# echo DEBUG 2 $id

# check that the site isn't already in the spool or queue:
test -d .q-spool/$id && error --exit 1 site $site is already spooled
test -d .q/$id && error --exit 1 site $site is already queued

# now set attributes in the site object for the spool and queue operations:

# delete any existing queue attributes, with prefix 'q-', ignore errors:
rm $site/q-* 2> /dev/null

now=$(date +%s)
test -n "$delay" && test $delay -gt 0 && {
    future=$((now+delay))
    touch -d @$future $site/q-DELAY
    }

test -n "$timeout" || error --exit 21 missing required timeout value
# TODO: check that $timeout and $delay are integer values!!
future=$((now+delay+timeout))
touch -d @$future $site/q-TIMEOUT

test -n "$priority" && touch $site/q-PRIORITY=$priority

# now set link to site object in spool:
# ... but first check that it's not already there!
test -L .q-spool/$id && error --exit 22 site $site is already in spool on 2nd check
ln -s ../$site .q-spool/$id

# check to make sure the link actually points to a site object:
test -e .q-spool/$id/@radio || {
    rm .q-spool/$id
    echo FAILED
    error "STAT .q-spool/$id: $(/usr/bin/stat .q-spool/$id)"
    error "READLINK -f .q-spool/$id: $(/bin/readlink -f .q-spool/$id)"
    error --exit 23 failed to resolve $site site object as .q-spool/$id
    }

# make sure the queue manager is running:
(   set -C
    >.@PID && {
        ($tob $self.run &)
        }
    set +C
    ) 2>/dev/null

# and WAIT for the queue manager to give a go or no-go:
until test -e $site/q-PASSED -o -e $site/q-FAILED; do
    sleep 1
done

test -e $site/q-FAILED && echo FAILED && exit 1

# check that passed attribute is actually set, just in case:
test -e $site/q-PASSED || error --exit 24 should not happen

test -n "$notify" && {
    now=$(date +%s)
    future=$((now+10))
    touch -d @$future $site/q-TIMEOUT
    test -L .q-notified/$id && error --exit 25 site $site already in notified queue
    ln -s ../$site .q-notified/$id
    # inform client that the site can be called again with --notified
    echo PASSED
    # check to make sure the link actually points to a site object:
    test -e .q-notified/$id/@radio || {
        errlog=/tmp/commserver-run-q-notified-error
        msg=$(printf "%s %s: %s symlink failed\n" \
            $(date +%j:%H:%M:%S) $TOB_method .q-notified/$id)
        echo "$msg" >> $errlog
        stat .q-notified/$id >> $errlog
        ls .q-notified/$id/ >> $errlog
        ls $site/ >> $errlog
        }
    exit 0
    }

exec $tob $site.call

exit 0

NAME
    CommServer.call -- request a site to call

DESCRIPTION
    Adds the specified site to the queue spool, then runs the
    pick-site-to-call method which moves the site from the spool into
    the queue.

    The method accepts a few command line options, and the command line
    can also be used to specify a site to query (and also options to that
    query) as an alternative to the query dialog.

COMMAND LINE OPTIONS
    --as-notified
        must be specified in the call is in response to a previous call
        requesting notification

    -h
        show brief synopsis, then exit
    
    --help
        show this manpage, then exit
    
COMMANDS
    Enter one of the following at the 'query:' prompt:

    call SITE [--notify] [--priority NUMBER] [--timeout SECONDS] [--delay SECONDS]
        check that site exists, create queue object in spool
        see SITE OPTIONS below

    ls [...]
        list contents of commserver object

    q
    quit
        exit with status 0

    h
        show brief synopsis

    help
        show manpage

SITE OPTIONS
    --notify
        after site is chosen and a route locked, don't initiate connection
        but notify client that a connection can be made
    
    --priority NUMBER
        optional priority number to favor one site over another; no default
    
    --delay SECONDS
        specify how long to leave site in the queue spool before moving
        it to the active queue; default is 0 seconds

    --timeout SECONDS
        specify how long attempt to call should persist in queue
        default is 60 seconds
    
SPECIAL ATTRIBUTES
    The following files are created as attributes in the site object to
    communicate settings to other methods.

    q-PRIORITY
    q-DELAY
    q-TIMEOUT
    
AUTHOR
    Ken.Irving@alaska.edu 2010

