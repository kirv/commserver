#!/bin/bash

errorlog=/tmp/commserver-call-error

error () { # exit only if --exit NUMBER is given, no output to log if NUMBER is 1
    test -n "$1" -a $1 == --exit && shift && exitvalue=$1 && shift
    tmstamp=$(date --iso=sec)
    printf "%s %s %s\n" $tmstamp ${exitvalue:---} "$*" >&2
    test -n "$exitvalue" -a $exitvalue == 1 && exit 1
    printf "%s %s %s\n" $tmstamp ${exitvalue:---} "$*" >> $errorlog
    test -n "$exitvalue" && exit $exitvalue
    }

tob=/usr/local/bin/tob
self=.

# default values for options:
timeout=60
delay=0
unset notify
unset notified

synopsis="$(basename $0) [--notify|--notified|-h|--help] [SITE [SITE_OPTIONS]]"

# parse and handle command line options:
while test -n "$1" -a "${1:0:1}" == '-'; do
    opt=$1 && shift
    case $opt in
        --notify)   notify=1;;
        --notified) notified=1;;
        --help)     exec awk '/^NAME$/{ok=1}ok{print}' $0;;
        -h)         echo $synopsis && exit 0;;
        *)          error --exit 11 unknown option: $opt;;
    esac
done

# assume first that the query is specified on the command line:
query=( call "$@" ) && unset query[0]

# run query loop on stdin if query was not given on command line:
test -n "$1" || {
    printf 'query: '
    while read -a query; do
        # special case: filter trailing \r character if present in last word:
        i=$((${#query[@]}-1))
        query[i]=${query[i]%$'\r'}
        cmd=$query
        unset query[0]
        case $cmd in
            call)   break ;;
            ls)     ls "${query[@]}" ;;
            q|quit) echo goodbye!; exit 0 ;;
            help)   awk '/^NAME$/{ok=1}ok{print}' $0 ;;
            h)      printf "    %s\n" \
                        'call SITE [OPTIONS] -- queue site to call' \
                        'ls [...]           -- list commserver object contents' \
                        'q|quit             -- exit' \
                        'h                  -- show short help' \
                        'help               -- show man page'
                    ;;
            *)      printf "\a?\n" ;;
        esac
        printf 'query: '
    done
    }

site=${query[1]} && unset query[1]

# remap query, converting '--opt=val' options to '--opt val' form:
query=(${query[@]//=/ }) # convert '--opt=val' options to '--opt val' form
qrystr="call $site ${query[@]}"

# parse query (note that some options may also have been on command line):
i=0; while test -n "${query[i]}"; do
    case ${query[i]} in
        --notify)       notify=1 ;;
        --notified)     notified=1 ;;
        --priority)     ((i+=1)); priority=${query[i]} ;;
        --timeout)      ((i+=1)); timeout=${query[i]} ;;
        --delay)        ((i+=1)); delay=${query[i]} ;;
        *)              error --exit 13 unknown option: ${query[i]} in "($qrystr)";;
    esac
    ((i+=1))
done

test -n "$notify" -a -n "$notified" &&
    error --exit 28 both --notify and --notified given in query "<$qrystr>"

# make sure site exists and is a radio site:
test -n "$site" || error --exit 26 no site specified in query "($qrystr)"
test -d "$site" || { # site does not resolve directly, so try harder...
    for dir in _ _/*; do
        test -d $dir/$site || continue
        site=$dir/$site
        break
    done
    test -d $site || error --exit 12 no site: $site
    # report sites found in the *temporary* _/transition/ tree:
    test $site != ${site#_/transition} && error resolved site as $site
    }
test -e $site/@radio || error --exit 27 no radio found as $site/@radio
# use site name or @id attribute if available for link names:
id=${site##*/}
test -e "$site/@id" && id=$(<$site/@id)
id=${id// /_} # just in case, replace any spaces with underscores

## assert: variable site points to a radio site, id can be used for link names

## if a callback is pending, the site is locked, and any but a callback
## query should fail.

test -e .q-callback/$id && { # callback is pending for site, fail anything else
    test -n "$notified" || { # --notified option was not passed
        echo FAILED callback pending for $id
        error --exit 11 callback pending for $id, $site
        }
    rm .q-callback/$id && exec $tob $site.call
    error --exit 17 failed to remove $id for $site from notified queue
    }

test -n "$notified" && 
    error --exit 29 invalid/late callback with --notified for $id

# check that the site isn't already in the spool or queue:
test -d .q-spool/$id && error --exit 1 site $site is already spooled
test -d .q/$id && error --exit 1 site $site is already queued

# now set attributes in the site object for the spool and queue operations:

# delete any existing queue attributes, with prefix 'q-', ignore errors:
rm $site/q-* 2> /dev/null

now=$(date +%s)
test -n "$delay" && test $delay -gt 0 && {
    future=$((now+delay))
    touch -d @$future $site/q-DELAY
    }

test -n "$timeout" || error --exit 21 missing required timeout value
# TODO: check that $timeout and $delay are integer values!!
future=$((now+delay+timeout))
touch -d @$future $site/q-TIMEOUT

test -n "$priority" && touch $site/q-PRIORITY=$priority

# now set link to site object in spool:
# ... but first check that it's not already there!
test -L .q-spool/$id && error --exit 22 site $site is already in spool on 2nd check
ln -s ../$site .q-spool/$id

# check to make sure the link actually points to a site object:
test -e .q-spool/$id/@radio || {
    rm .q-spool/$id
    echo FAILED
    error "STAT .q-spool/$id: $(/usr/bin/stat .q-spool/$id)"
    error "READLINK -f .q-spool/$id: $(/bin/readlink -f .q-spool/$id)"
    error --exit 23 failed to resolve $site site object as .q-spool/$id
    }

# make sure the queue manager is running:
( set -C; >.@run-pid && { ($tob $self.run &); }; set +C;) 2>/dev/null

# and WAIT for the queue manager to give a go or no-go:
until test -e $site/q-PASSED -o -e $site/q-FAILED; do
    sleep 1
done

test -e $site/q-FAILED && echo FAILED && exit 1

# check that passed attribute is actually set, just in case:
test -e $site/q-PASSED || error --exit 24 should not happen

test -n "$notify" && {
    now=$(date +%s)
    future=$((now+10))
    touch -d @$future $site/q-TIMEOUT
    test -L .q-callback/$id && error --exit 25 site $site already in notified queue
    ln -s ../$site .q-callback/$id
    # inform client that the site can be called again with --notified
    echo PASSED
    # check to make sure the link actually points to a site object:
    test -e .q-callback/$id/@radio || {
        errlog=/tmp/commserver-run-q-callback-error
        msg=$(printf "%s %s: %s symlink failed\n" \
            $(date +%j:%H:%M:%S) $TOB_method .q-callback/$id)
        echo "$msg" >> $errlog
        stat .q-callback/$id >> $errlog
        ls .q-callback/$id/ >> $errlog
        ls $site/ >> $errlog
        }
    exit 0
    }

exec $tob $site.call

exit 0

NAME
    CommServer.call -- request a site to call

DESCRIPTION
    Adds the specified site to the queue spool, then runs the
    pick-site-to-call method which moves the site from the spool into
    the queue.

    The method accepts a few command line options, and the command line
    can also be used to specify a site to query (and also options to that
    query) as an alternative to the query dialog.

COMMAND LINE OPTIONS
    --as-notified
        must be specified in the call is in response to a previous call
        requesting notification

    -h
        show brief synopsis, then exit
    
    --help
        show this manpage, then exit
    
COMMANDS
    Enter one of the following at the 'query:' prompt:

    call SITE [--notify] [--priority NUMBER] [--timeout SECONDS] [--delay SECONDS]
        check that site exists, create queue object in spool
        see SITE OPTIONS below

    ls [...]
        list contents of commserver object

    q
    quit
        exit with status 0

    h
        show brief synopsis

    help
        show manpage

SITE OPTIONS
    --notify
        after site is chosen and a route locked, don't initiate connection
        but notify client that a connection can be made
    
    --priority NUMBER
        optional priority number to favor one site over another; no default
    
    --delay SECONDS
        specify how long to leave site in the queue spool before moving
        it to the active queue; default is 0 seconds

    --timeout SECONDS
        specify how long attempt to call should persist in queue
        default is 60 seconds
    
SPECIAL ATTRIBUTES
    The following files are created as attributes in the site object to
    communicate settings to other methods.

    q-PRIORITY
    q-DELAY
    q-TIMEOUT
    
AUTHOR
    Ken.Irving@alaska.edu 2010

