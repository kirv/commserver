#!/usr/bin/perl -w
use warnings;
use strict;

use constant NODEROOT => '/var/local/commserver/';
use constant MAX_PATH_SIZE => 6; # target node + 4 repeaters + base node
use constant OSEP => ','; # output field separator
use constant BUILD_PATHS_LIMIT => 10;

## purpose: given a node name, find one or more paths from node to base

my $target = shift;

my $debug;
if ( $target =~ m/^-/ ) {
    if ( $target eq '-d' ) {
        $debug = 1;
        }
    else {
        die "unknown option: $target\n";
        }
    $target = shift;
    }

my ($area) = $target =~ m{^(.+/)[^/]+$};

die qq(SYNOPSIS: $0 NODENAME\n) unless defined $target;
die qq(no node: $target\n) unless -e NODEROOT . $target;

$target = symlink_target($target) if -l NODEROOT . $target;

# print "DEBUG target: $target\n";

my %node; # global hash of each node visited
my %alias; # global hash of node aliases (symlinked nodes)

## recursively visit all uplink nodes:

scan_node_uplinks($target);

debug_nodes() if $debug;

## construct all paths from target node to all base nodes:

my @path = ( [ $target ] ) ; ## seed path tree
my $pass_count = 0;
while ( build_paths() ) {
    die "$target: too many passes ($pass_count) through build_paths()\n"
        if ++$pass_count > BUILD_PATHS_LIMIT;
    }

debug_culled_paths() if $debug;

## print all paths to standard output:

my @output;
foreach my $pathref ( @path ) {
    next if @$pathref > MAX_PATH_SIZE;
    push @output, join(OSEP, @$pathref);
    }
print "$_\n" foreach sort @output;

## end of program; subroutines follow

sub build_paths {
    ## all paths are complete when they end at a leaf node
  # print "\nDEBUG: ", scalar @path, " paths defined:\n";
  # foreach my $pathref ( @path ) { 
  #     print "DEBUG:     ( @$pathref )\n";
  #     }
    my @path_copy = @path; # static copy so only one pass is made
    my $index = -1;
    my @doomed_path;
    foreach my $pathref ( @path_copy ) { 
      # print "DEBUG 1: ( @$pathref )\n";
        $index++;
        ## inspect end of path; clone another path if not a leaf node
        my $node = $pathref->[-1];
      # print "DEBUG end node: $node\n";
        next unless ( defined %{$node{$node}} || defined $alias{$node} ); ## not defined if leaf node
        ## ASSERT: not a leaf node
        my %inpath; # hash of all nodes in the path
      # $inpath{$_} = 1 foreach @$pathref;
        foreach my $node ( @$pathref ) {
            $inpath{$node} = 1;
            $inpath{$alias{$node}} = 1 if exists$alias{$node};
          # print "DEBUG: $node is in path\n";
            print "DEBUG: $alias{$node} is in path, too\n" if exists$alias{$node};
            }
      # print "DEBUG 2: ( @$pathref )\n";
      # print "DEBUG 2: $node\n";
        my $n = 0;
      # foreach my $node2 ( keys %{$node{$node}} ) {
      #     print "DEBUG:--- TRY $node --to-- $node2\n";
      #     }
        foreach my $node ( keys %{$node{$node}} ) {
          # print "DEBUG: TRY node $node\n";
            next if $inpath{$node};  # skip node if already in path
            unless ( $n++ ) { # process the first entry
              # print "DEBUG: extend path to $node\n";
                push @$pathref, $node;
              # print "        ( @$pathref )\n";
                next;
                }
          # print "DEBUG: clone new path for $node\n";
            push @path, [ @$pathref ]; # clone path
            $pathref->[-1] = $node; # replace last node
          # print "        ( @$pathref )\n";
            }
        if ( $n == 0 ) { # no uplinks found not already in this path
            ## ASSERT: none of the available links will work
            ## therefore, this path is doomed
          # print "DEBUG: doomed path, #$index:\n";
          # print "    ( @$pathref )\n";
          # print "    ( @{$path[$index]} )\n";
            push @doomed_path, $index;
          # die "doomed\n";
            }
        }

  # print "DEBUG: doomed: ";
    while ( my $index = pop @doomed_path ) {
      # print "$index, ";
        splice @path, $index, 1
        }
  # print "\n";

  # print "DEBUG doomed: #$_ or @{$path[$_]}\n" foreach @doomed_path;
  # splice @path, $_, 1 foreach @doomed_path; # note: delete() won't do this!

    my $notdone;
    foreach my $pathref ( @path ) { # check for non-leaf end nodes:
      # print "DEBUG 3: ( @$pathref )\n";
        ## inspect end of path; clone another path if not a leaf node
        my $node = $pathref->[-1];
      # print "DEBUG: check $node for not-done...\n";
        $notdone = 1 if defined %{$node{$node}} || defined $alias{$node};
        }
    return $notdone;
    }

sub scan_node_uplinks { # follow uplinks for node
    my $node = shift;
  # print "DEBUG: processing $node\n";
    my $real_node = symlink_target($node) if -l NODEROOT . $node;
    
    die qq(scan_node_uplinks($node) requires fully qualified node name\n)
        unless $node =~ m{^(.*/)([^/]+)$};
    return qq(node $node already processed\n) if exists $node{$node};

    ## need to get uplinks; resolve node to real_node if a symlink
    my $dotnode = defined $real_node ? $real_node : $node;
    $dotnode =~ s{^(.+)/([^/]+)$}{$1/.$2};
    my $area = $1;

    $node{$node} = undef;
    $node{$real_node} = undef if defined $real_node;
    return unless -d NODEROOT . "$dotnode/UPLINK/"; # no uplinks

    opendir UPLINKS, NODEROOT . "$dotnode/UPLINK/" or die "failed to open UPLINK/, $!\n";
    my @links = readdir UPLINKS;
    close UPLINKS;

    my %link; # hash of uplinks from this node
    foreach my $link (@links ) {
        next if $link =~ m/^\./; # skip dot files
        $link = "$area/$link" unless $link =~ s{::}{/}g;
        $link{$link} = undef;
        die "linked node $link not found\n" unless -e NODEROOT . $link;
        scan_node_uplinks($link) unless exists $node{$link};
        }
    $node{$node} = \%link;
    $node{$real_node} = \%link if defined $real_node;
    return;
    }

sub symlink_target { # replace with symlink target
    my $node = shift;
  # print "DEBUG symlink(): $node\n";
    die qq($node is not a symlink\n) unless -l NODEROOT . $node;
    my $symlink = readlink NODEROOT . $node;
    $node =~ s{/[^/]+}{/$symlink};
  # print "DEBUG symlink(): $node\n";
    $node =~ s{[^/.]+/\.\./}{}; # simplify  foo/../bar/etc to bar/etc
  # print "DEBUG symlink(): $node\n";
    return $node;
    }

sub debug_nodes {
    print "DEBUG: nodes and uplinks:\n";
    foreach my $node ( sort keys %node ) {
        print "node: $node\n";
        my ($pnode) = $node =~ m{([^/]+)$};
        unless ( defined %{$node{$node}} ) {
          # print "$pnode -- leaf node\n";
            print "    $pnode --|\n";
            next;
            }
        foreach my $link ( sort keys %{$node{$node}} ) {
            my ($plink) = $link =~ m{([^/]+)$};
          # print "$pnode --to-- $plink: ", $node{$node}->{$link}, "\n";
          # print "$pnode --to-- $plink\n";
            print "    $node --to-- $link";
            print "  ($node{$node}->{$link})" if defined $node{$node}->{$link};
            print "\n";
            }
        }
    }

sub debug_culled_paths {
    print "DEBUG: culled paths, too many hops:\n";
    foreach my $pathref ( @path ) {
        next if @$pathref <= MAX_PATH_SIZE;
        my $fields = @$pathref;
        print join(OSEP, $fields, @$pathref), "\n";
        }
    print "\n";
    }
