#!/usr/bin/perl
# !/usr/bin/perl -w
use strict;
use warnings;

use Expect;
use FreeWave_Radio::Callbook;

use constant TMPDIR => '/tmp/';
use constant DEBUG => 1;
use constant REMOTE_PROMPT_RETRIES => 20;

use constant DEBUG_STEPS_FILE => "/tmp/commserver-debug-steps";
use constant CALL_SUMMARY_FILE => "/var/local/log/commserver-call-summary";

my $starttime = time;
my $time2_ready2dial;
my $time2_connect;

open DEBUG_STEPS, ">>", DEBUG_STEPS_FILE or die $!;
select DEBUG_STEPS;
$| = 1; ## turn buffering off 
select STDOUT;

print DEBUG_STEPS "initializing\n";

my $sitename; # store for call summary output...
my @call_summary;

my %siteindex;

## This method expects to find:
##      @LOCK containing base and repeater nodes
##      @radio containing the object's radio number
##      @prompt, either in the site or inherited
## 
## The method does, in turn:
##      connects to the base radio
##      checks its callbook
##      configures the callbook if necessary
##      calls the target site
##      attempts to elicit the prompt from the remote node
##      return CONNECT if prompt was seen
##      pass all i/o to/from client-remote
##      break connection if:
##          "BAIL!" is received from the client
##          session timeout limit is exceeded
##          client drops the connection
## 
## This program should then try to get radio stats from the base radio

my @attr_path = ( split ':', $ENV{TOB_attribute_search_paths} );
my @method_path = ( split ':', $ENV{TOB_method_search_paths} );

my $prompt;
for my $p ( @attr_path ) {
    next unless -e "$p/\@prompt";
    open PROMPT, '<', "$p/\@prompt"
        or die "failed to open $p/\@prompt for reading\n";
    chomp ($prompt = <PROMPT>);
    close PROMPT or die $!;
    }

die "site object is not locked\n" unless -e '@LOCK';
die "site object is locked by another site\n" unless -s '@LOCK';

open ROUTE, '<', '@LOCK'
    or die "failed to open \@LOCK\n";
chomp( my $route = <ROUTE> );
close ROUTE or die $!;

my ($base, @repsite) = split ' ', $route;

open RADIO, '<', '@radio'
    or die "failed to open \@radio\n";
chomp( my ($radio) = <RADIO> );
close RADIO or die $!;

open BASE, '<', "$base/\%ip2radio" 
    or die "failed to open $base\%ip2radio in base\n";
my ($host, $port);
while ( <BASE> ) {
    chomp;
    $host = $1 if m/host=(\S+)/;
    $port = $1 if m/port=(\S+)/;
    }
close BASE or die $!;

my @repeater;
for my $site ( @repsite ) {
    die "no lock in repeater $site\n"
        unless -e "$site/\@LOCK";
    die "lock in repeater $site is not a repeater lock\n"
        unless -s "$site/\@LOCK" == 0;
    open REP, '<', "$site/\@radio"
        or die "failed to open \@radio in repeater $site\n";
    chomp( my $repeater = <REP> );
    push @repeater, $repeater;
    close REP or die $!;
    }

if ( 1 ) {
    print 'attr_path: ', join(',', @attr_path), "\n";
    print 'method_path: ', join(',', @method_path), "\n";
    print "prompt: $prompt\n";
    print "route:\n\t", join("\n\t", $base, @repsite), "\n";
    print "host: $host\n";
    print "port: $port\n";
    print "radios:\n\t", join("\n\t", $radio, @repeater), "\n";
    
    exit 0;
    }

my %query = (
    host => undef,     # ip host name or number
    port => undef,     # ip port number
    radio => undef,    # target radio, as site name or radio number
    repeater => [],    # repeaters, site name or radio number
    prompt => undef,
    action => '',
    );

$| = 1; ## turn buffering off on STDOUT to client
    

## ASSUME that the query is now fully specified

print DEBUG_STEPS qq(query parameters:\n),
    qq(    radio $query{radio}\n),
    qq(    host $query{host}\n),
    qq(    port $query{port}\n);

push @call_summary, $query{host}, $sitename;

my $exp = Expect->new();
# $exp->exp_internal(1);
$exp->raw_pty(1); # sets the pty to raw mode

$exp->log_stdout(0); ## 0=supress, 1=copy process output to stdout
$exp->log_file( TMPDIR . "commserver.session", "w"); # "commserver-$$.session"

my @nc_options = ();

if ( $query{host} =~ m/^http:.+/ ) { # special case: URL contains dynamic ip
    require LWP::Simple;
    my $urlfile = LWP::Simple::get($query{host}) or
        die qq(no host file found at "$query{host}"\n);
    $query{host} = (split("\n", $urlfile))[0]
        or die qq(no host ip found at "$query{host}"\n);
  # print qq(DEBUG: obtained ip "$query{host}"\n);
    }

print DEBUG_STEPS qq(calling remote host...\n);

$exp->spawn("/bin/nc", @nc_options, $query{host}, $query{port})
    or die "Cannot spawn nc: $!\n";

$exp->restart_timeout_upon_receive(1);
my $timeout = 10;

## send a couple of escapes in case radio is left in config mode...
$exp->send("\e\e");

## ASSERT: radio should be in command mode

print DEBUG_STEPS qq(sending radio setup commands...\n);

# invoke radio setup menus:
$exp->send("ATXS");
$exp->expect($timeout, "Enter Choice")
    or timedout('no radio setup menu');

# open callbook:
$exp->send("2");
$exp->expect($timeout, "Enter all zeros") # (000-0000) as your last number in list
    or timedout('no radio callbook menu');

my $callbook = FreeWave_Radio::Callbook->new($exp->before());
my $entry;
my $rep_path;
$entry = $callbook->repeater_path_entry($rep_path) if defined $rep_path;

# if ( $query{host} eq 'sagriver' ) {
#     require Data::Dumper;
#     open CHECKSAG, '>>', '/tmp/checksag';
#     print CHECKSAG  Data::Dumper::Dumper $callbook;
#     close CHECKSAG;
#     }
# 
print DEBUG_STEPS qq(using repaater path $entry\n) if defined $entry;

my $entry_type = defined $entry ? 'exists' : 'new';

unless ( defined $entry ) { # existing repeater path was not found, so configure...
    $entry = '8';
    print DEBUG_STEPS qq(configuring repaater path 8...\n);
    # clear entry #9:
    $exp->send("9");
    $exp->expect($timeout, "9") # number is echoed
        or timedout('no callbook menu command "9" echo, zeroing entry');
    $exp->expect($timeout, "Enter New Number")
        or timedout('no "Enter New Number" callbook prompt after "9" command, zeroing entry');
    $exp->send("0000000");
    $exp->expect($timeout, "Enter all zeros")
        or timedout('no "Enter all zeros" callbook prompt, zeroed entry "9"');
    
    print DEBUG_STEPS qq(entering radio number\n);
    
    $exp->send("8");
    $exp->expect($timeout, "8") # number is echoed
        or timedout('no callbook menu command "8" echo');
    $exp->expect($timeout, "Enter New Number")
        or timedout('no "Enter New Number" callbook prompt after "8" command');
    $exp->send($query{radio});
    
    $exp->expect($timeout, "Enter Repeater")
        or timedout('no "Enter Repeater" callbook prompt, entry "8"');
    
    unless ( @{$query{repeater}} ) { # no repeaters
        $exp->send("\e");
        $exp->expect($timeout, "Enter all zeros")
            or timedout('no "Enter all zeros" callbook prompt, entry "8", no repeaters');
        # menu state: still in callbook
        } 
    else { # repeaters are called out
        my $n = 0; ## refer to repeaters ordinally, i.e., 1, 2, 3, 4
        while ( defined $query{repeater}->[++$n-1] ) {
            print DEBUG_STEPS qq(entering repeater number\n);
            if ( $n == 1 ) { # enter 1st repeater
                $exp->send($query{repeater}->[$n-1]);
                $exp->expect($timeout, "Enter Repeater")
                    or timedout("no ${n}th \"Enter Repeater\" callbook prompt");
                }
            elsif ( $n == 2 || $n == 4 ) { # transaction concludes after entry
                $exp->send($query{repeater}->[$n-1]);
                $exp->expect($timeout, "Enter all zeros")
                    or timedout("no \"Enter all zeros\" callbook prompt ($n)");
                }
            elsif ( $n == 3 ) { # need to use entry 9
                ## ASSERT: top level callbook menu
                $exp->send("9");
                $exp->expect($timeout, "9") # number is echoed
                    or timedout("no callbook menu command \"9\" echo, repeater $n");
                $exp->expect($timeout, "Enter New Number")
                    or timedout("no \"Enter New Number\" callbook prompt after \"9\" command, repeater $n");
                $exp->send("9999999"); ## special value for extended repeater path
                $exp->expect($timeout, "Enter Repeater")
                    or timedout("no 1st \"Enter Repeater\" callbook prompt, entry \"9\", repeater $n");
                $exp->send($query{repeater}->[$n-1]);
                $exp->expect($timeout, "Enter Repeater")
                    or timedout("no 2nd \"Enter Repeater\" callbook prompt, entry \"9\", repeater $n");
                }
            }
        ## ASSERT: may be at top level or waiting for 2nd or 4th repeater
        if ( @{$query{repeater}} % 2 ) { # odd number of repeaters, 1 or 3
            $exp->send("\e"); # terminate 
            $exp->expect($timeout, "Enter all zeros")
                or timedout('no callbook menu 2 "Enter all zeros" prompt, ending entries');
            }
        }
    }

## ASSERT: menu state: still in callbook
$exp->send("\e"); # escape back to main menu
$exp->expect($timeout, "Enter Choice")
    or timedout('no main menu "Enter Choice" prompt, after callbook entries');

$exp->send("\e"); # escape out of config mode to command mode (no response)
$exp->send("\e"); # send another just for good measure??

$timeout = 20;

sleep 1;

my $dial_string = "ATXC${entry}ATD$query{radio}";

print DEBUG_STEPS qq(ready to dial target radio with $dial_string\n);

$time2_ready2dial = time;

$rep_path = '' unless $rep_path; # for output...
push @call_summary, $dial_string, $entry_type, $rep_path;

# $exp->send("ATXC8ATD$query{radio}"); # try to connect to the target radio
$exp->send($dial_string); # try to connect to the target radio
$exp->expect($timeout, "OK")  # command was acted upon
    or timedout('no "OK" response from ATDT command');
print DEBUG_STEPS qq(saw "OK"\n);
$exp->expect($timeout, "CONNECT")  # first radio (target or repeater) reached
    or timedout('no "CONNECT" response');
print DEBUG_STEPS qq(saw "CONNECT"\n);

my $see_target;
# print "looking for $query{type} prompt...\n" if $query{type};
if ( $query{prompt} ) {
    my $retries = $query{retries} || REMOTE_PROMPT_RETRIES;
    print DEBUG_STEPS qq(sending CR\n);
    $exp->expect(1, '-re', ".*"); 
    $exp->send("\r");
 #  my $regex_prompt = $query{prompt};
 #  $regex_prompt =~ s/([?.[\]+*])/\\\\$1/g;
 ## if ( $query{prompt} eq '*' ) {
 ##     print "PROMPT: was: <*> now <$regex_prompt>\n";
 ##     }
 ## $see_target = $exp->expect(1, '-re', ".*$regex_prompt"); 
    $see_target = $exp->expect(1, $query{prompt}); 
  # while ( ! $see_target && --$retries ) {
    while ( ! $see_target ) {
        last unless --$retries;
        print DEBUG_STEPS qq{sending CR ($retries retries)\n};
        $exp->send("\r"); # try to get a prompt
        $see_target = $exp->expect(1, $query{prompt}); # wait for 1 second
      # print '.'; # progress indicator
        }
    }

if ( $see_target ) {
    print DEBUG_STEPS qq(saw target prompt, sending "CONNECTED" to client\n);
    print "CONNECTED\r\n";
    push @call_summary, 'ok';
    }
else {
    print DEBUG_STEPS qq(no target prompt, sending "NO_PROMPT_SEEN" to client\n);
    print "NO_PROMPT_SEEN\r\n";
    print DEBUG_STEPS qq(quitting\n);
    push @call_summary, 'no';
    log_call_summary();
    die "bye!\n";
    }

$time2_connect = time;

print DEBUG_STEPS qq(going interactive with client...\n);

$exp->interact(\*STDIN, 'BAIL!');
# $exp->interact();

print DEBUG_STEPS qq(client has terminated connection\n);

log_call_summary();

## client is done! 
## todo: 
##    test for doneness of client
##    reset remote base radio
##    gather connection stats
##    log info somewhere

exit 0;

sub log_call_summary {
    my ($s, $m, $h, $y, $d) = (localtime $starttime)[0, 1, 2, 5, 7];
    my $tmstamp = sprintf "%4d-%03d-%02d:%02d:%02d", $y+1900, $d+1, $h, $m, $s;
    print "DEBUG $tmstamp\n";
    my $tm_up2dial = $time2_ready2dial ? $time2_ready2dial - $starttime . 's' : '-';
    my $tm_connect = $time2_connect ? $time2_connect - $starttime . 's' : '-';
    my $tm_total = time - $starttime . 's';
    open CALL_SUMMARY, ">>", CALL_SUMMARY_FILE or die $!;
    print CALL_SUMMARY
        join(',', $tmstamp, @call_summary, $tm_up2dial, $tm_connect, $tm_total),
        "\n";
    close CALL_SUMMARY;
    }

sub timedout {
    my $msg = shift;
    $msg = 'n/a' unless defined $msg;
    push @call_summary, "timedout:$msg";
    log_call_summary();
    print DEBUG_STEPS qq(expect() timed out: $msg\n);
    print "ABORTING CONNECTION\r\n";
    $exp->send("\e\e"); # send escapes in case in radio setup mode
    die qq(expect() timed out: $msg\n);
    }

